## Learning for Optimization with Virtual savant

---

최적화 문제(Optimization Problem)는 다양한 학문 분야에서 발생하며, 이를 해결하기 위해서는 현대의 병렬 컴퓨팅 플랫폼(Parallel Computing Platform)을 효과적으로 활용할 수 있는 효율적인 알고리즘이 요구된다. 최근 기계학습(Machine Learning)의 비약적인 발전은, 최적화 알고리즘에 학습 능력을 통합함으로써 대규모이고 복잡한 문제를 보다 효율적으로 해결할 수 있는 가능성을 제시한다.

본 학위논문에서는 **가상 서번트(Virtual Savant)** 라는 패러다임을 탐구한다. 이 패러다임은 기계학습과 병렬 컴퓨팅을 결합하여 최적화 문제를 해결하기 위한 것이다. **가상 서번트**는 특정 영역에서 평균을 훨씬 능가하는 능력을 보이는 정신적 상태인 **서번트 증후군(Savant Syndrome)** 에서 영감을 받아 고안되었다. 서번트 증후군과의 유추에 따라, 가상 서번트는 과거에 해결된 문제 인스턴스들로부터 패턴을 추출하여, 주어진 최적화 문제를 대규모 병렬 방식(Massively-Parallel Fashion)으로 해결하는 방법을 학습한다.

본 논문에서는 가상 서번트를 다음 세 가지 최적화 문제에 적용하였다:

1. 소프트웨어 공학(Software Engineering) 관련 문제
2. 작업 스케줄링(Task Scheduling) 문제
3. 대중교통(Public Transportation) 관련 문제

가상 서번트의 성능은 다양한 컴퓨팅 플랫폼에서 평가되었으며, 실험 결과는 정확한 해(Exact Solution) 및 근사 해법(Approximate Solution)과 비교되었다. 비교 대상에는 인공적으로 생성된 문제 인스턴스와 실제 기반 문제 인스턴스가 모두 포함되었다.

결과에 따르면, 가상 서번트는 다음과 같은 특징을 지닌다:

* 정확한 해를 도출할 수 있다.
* 문제의 크기가 커져도 효과적으로 확장(Scalability)된다.
* 다수의 연산 자원(Multiple Computing Resources)을 효과적으로 활용할 수 있다.

---

# 제1장 서론 (Introduction)

다양한 학문 분야에서 발생하는 최적화 문제(optimization problem)의 복잡성이 증가함에 따라, 대규모 연산 자원을 요구하는 알고리즘이 필요하게 되었다(Ausiello et al., 2012). 동시에 병렬 컴퓨팅(parallel computing)은 과학 계산(scientific computing)의 핵심 요소로 자리 잡았으며, 이는 고전적인 순차 시스템(sequential system)으로는 해결할 수 없는 복잡한 실제 문제들을 해결할 수 있게 해준다(Golub and Ortega, 2014). 그 결과, 광범위하게 사용되는 병렬 아키텍처는 다수의 연산 자원을 활용할 수 있는 병렬 알고리즘의 채택을 증가시키는 계기가 되었다.

현대 아키텍처의 이점을 활용하기 위해서는 소프트웨어 개발자가 병렬 프로그램(parallel program)을 구현할 수 있어야 한다. 이를 위해서는 병렬 프로그램을 처음부터 설계하거나 기존의 순차 구현을 병렬 아키텍처에 맞게 재설계할 수 있는 고도의 숙련된 프로그래머가 필요하다. 따라서 고도로 병렬화된 컴퓨터 플랫폼에서 실행되고 연산 자원의 수에 따라 확장 가능한 유연한(elastic) 프로그램을 자동으로 생성하는 기술에 대한 관심이 증가하고 있다(Darte et al., 2012). 이 문제를 해결하기 위한 방안으로 최근 기계학습(machine learning) 기술이 주목받고 있다.

최적화(optimization)와 기계학습(machine learning)은 밀접하게 관련된 분야이다. 그러나 지금까지의 대부분의 연구는 이 관계의 한 방향에 집중되어 있었는데, 즉 기계학습 기법에 최적화 기법을 적용하는 방향이다(예: 모델의 매개변수 최적화, 특징 선택(feature selection) 문제 등)(Sra et al., 2012). 반대로, 기계학습 기법을 사용하여 최적화 문제를 해결하는 방향은 일부 연구(Vlastelica et al., 2020; Vinyals et al., 2015)가 존재하나 아직 기여의 여지가 많다.

본 논문은 기계학습과 병렬 컴퓨팅의 이점을 활용하여 복잡한 최적화 문제를 해결하는 새로운 패러다임인 가상 서번트(Virtual Savant, 이하 VS)를 다룬다(Pinel et al., 2013). VS는 서번트 증후군(Savant Syndrome)에서 영감을 받은 기법으로, 특정 능력에서 평균을 뛰어넘는 능력을 보이는 정신적 특이 상태를 모방한 것이다. 이와 유사하게 VS는 문제의 과거 해결 사례로부터 패턴을 학습하여 새로운 문제를 해결한다. 이러한 설계 덕분에 VS는 대규모 병렬 컴퓨팅 아키텍처에서 실행될 수 있으며, 실행 시간을 크게 단축하고 문제의 크기에 따라 효과적으로 확장될 수 있다.

이 논문에서 다루는 연구의 주요 목표는 다음과 같다:

1. 병렬 프로그램 자동 생성과 기계학습과 최적화 간의 시너지 효과에 대한 관련 문헌 종합 검토.
2. VS의 전체 워크플로우(workflow)와 구현 정의.
3. 소프트웨어 공학 분야의 조합 최적화(combinatorial optimization) 문제인 다음 릴리스 문제(Next Release Problem, NRP)에 대한 VS의 적용 및 평가. 이 문제는 0/1 배낭 문제(0/1 Knapsack Problem, 0/1-KP)로 모델링됨.
4. 이기종 컴퓨팅 스케줄링 문제(Heterogeneous Computing Scheduling Problem, HCSP)에 VS를 적용하고, 다양한 연산 플랫폼 및 문제 크기에서의 확장성 분석.
5. 대중교통망(public transportation network)에서 발생하는 조합 최적화 문제인 버스 동기화 문제(Bus Synchronization Problem, BSP)에 VS를 적용하고, 인공 문제 및 현실 기반 문제에 대한 성능 평가.

이 연구 과정에서 아래와 같은 학술지 및 학회에 다수의 논문이 발표되었으며, 해당 논문과 그 주요 내용을 다음에 요약하였다.

(논문 목록은 생략 가능하며, 원할 경우 다음 응답에서 번역 포함 가능)

---

# 제2장

최적화를 위한 학습:
가상 서번트 패러다임 (Virtual Savant Paradigm)

이 장에서는 가상 서번트(Virtual Savant, 이하 VS) 패러다임을 소개합니다. 먼저 2.1절에서는 VS를 고안하게 된 동기를 설명하고, 2.2절에서는 VS 모델에 영감을 준 서번트 증후군(Savant Syndrome)에 대해 설명합니다. 이후 2.3절에서는 VS의 개념적 프레임워크를, 2.4절에서는 VS 패러다임의 구현 세부사항을, 마지막으로 2.5절에서는 VS 실행을 위해 구현된 병렬 기계학습 라이브러리 xphi-libsvm에 대한 실험적 평가를 제시합니다.

---

## 2.1 동기 (Motivation)

최적화(Optimization)는 주어진 목적 함수(Objective Function)를 최적화하는 해(solution)를 정의된 해 집합에서 찾는 작업입니다. 특히 조합 최적화(Combinatorial Optimization)는 유한 집합에서 해를 찾는 문제를 다룹니다. 조합 최적화 문제는 물류, 공급망 관리, 소프트웨어 공학, 교통 등 매우 다양한 분야에서 등장합니다. 이에 따라 해당 문제를 해결하기 위한 알고리즘에 대한 연구는 풍부하며, 정밀 해법(Exact Approach)뿐만 아니라 근사 해법(Approximation Algorithm)도 포함됩니다 (Woeginger, 2003; Blum and Roli, 2003; Aarts and Lenstra, 2003).

오늘날처럼 복잡하거나 대규모인 최적화 문제에서는 실행 시간과 계산 성능이 실용성에 직접적인 영향을 주기 때문에 매우 중요합니다. 병렬 컴퓨팅 플랫폼의 이용 가능성이 증가함에 따라, 병렬 알고리즘은 과학적 계산(scientific computing) 일반 및 최적화 연구 분야에서 핵심 기술이 되었습니다.

동시에 기계학습(Machine Learning)은 비약적인 발전을 이루었으며, 새로운 기법과 응용이 빠른 속도로 등장하고 있습니다 (Jordan and Mitchell, 2015). 기계학습 알고리즘은 훈련 데이터를 기반으로 모델을 구축하며, 명시적으로 프로그램되지 않아도 예측을 수행할 수 있습니다. 이러한 특성 덕분에 컴퓨터 비전(computer vision), 음성 인식(speech recognition), 의료 진단, 생물정보학(bioinformatics) 등 다양한 분야에서 역사적 데이터를 활용한 정확한 예측이 가능해졌습니다.

최적화와 기계학습은 본질적으로 밀접하게 연관된 분야이며, 두 연구 커뮤니티 간의 시너지는 점점 증가하고 있습니다 (Bennett and Parrado, 2006). 예를 들어 기계학습 모델의 매개변수 조정 및 특징 선택과 같은 많은 학습 문제들이 사실상 최적화 문제로 귀결됩니다 (Sra et al., 2012; Bottou et al., 2018). 반면, 기계학습 기법을 최적화 문제 해결에 적용하는 연구는 여전히 비교적 드뭅니다 (Bengio et al., 2021).

본 논문에서 다루는 VS는 기계학습 기법을 활용해 최적화 문제를 자동으로 해결하는 프로그램을 생성하고, 이를 병렬 실행함으로써 현대의 연산 자원을 효율적으로 활용할 수 있도록 설계된 새로운 패러다임입니다. 이 패러다임에 영감을 준 아이디어는 다음 절에서 설명합니다.

---

## 2.2 영감: 서번트 증후군 (Inspiration: the Savant Syndrome)

자연 컴퓨팅(Natural Computing)은 자연에서 아이디어를 얻어 복잡한 문제를 해결하는 계산 도구를 설계하는 분야입니다 (de Castro, 2006). 생물 영감 기반 기법(Bioinspired Techniques)은 복잡한 최적화 및 의사결정 문제에 널리 적용되어 왔으며 (Olariu and Zomaya, 2005), 문제 특화 지식 없이도 복잡한 탐색 공간을 효과적으로 탐색할 수 있다는 점에서 강력한 도구입니다.

예를 들어,

* 인공 신경망(Artificial Neural Networks, ANN)은 신경계를 모방했고,
* 진화 알고리즘(Evolutionary Algorithm, EA)은 생물의 진화 과정을 기반으로 했으며,
* 군집 지능(Swarm Intelligence)은 집단 생물의 행동을 참고하고,
* 인공 면역 시스템(Artificial Immune System)은 면역학에서 영감을 받았습니다.

본 논문에서 다루는 VS 역시 자연현상을 모방한 기법으로 간주될 수 있으며, 그 모티브는 바로 서번트 증후군(Savant Syndrome)입니다.

서번트 증후군은 상당한 정신 장애를 가진 개인이 특정 영역에서 비정상적으로 높은 능력을 보이는 드문 상태입니다 (Treffert, 2006). 이들은 보통 기억, 계산, 예술 등 특정 능력에서 매우 뛰어나며, 사고 과정은 아직 과학적으로 완전히 밝혀지지 않았습니다. 그러나 주요 가설은 이들이 패턴 인식(Pattern Recognition)을 통해 학습한다는 것입니다 (Pring, 2005; Heaton and Wallace, 2004). 예컨대 어떤 환자는 소수(prime number)의 개념을 명확히 이해하지 못하면서도, 소수를 식별하거나 나열할 수 있습니다.

서번트 증후군은 자폐 스펙트럼 장애(Autistic Spectrum Disorder)를 포함한 다른 발달 장애와 함께 나타나는 경우가 많으며, 남성에게서 더 자주 보고됩니다 (Rimland, 1978). 이들의 능력은 주로 다음 영역에 국한됩니다:

* 음악 (다중 악기 연주, 즉흥연주 등)
* 미술 (기억 기반의 그림 그리기, 조각)
* 달력 계산 (특정 날짜가 무슨 요일인지 계산 등)
* 수학 (순간 계산, 소수 나열 등)
* 공간 인식 (지도 제작, 거리 추정, 경로 계획 등)

보통 한 가지 능력에서만 특출나지만, 일부는 여러 능력을 동시에 보이기도 하며, 모든 서번트에게 공통적으로 뛰어난 기억력(Memory)이 관찰됩니다.

---

## 2.3 가상 서번트 (Virtual Savant)

이 절에서는 가상 서번트(Virtual Savant, 이하 VS)를 소개합니다. 먼저, VS의 전반적인 개요를 설명한 후, 각 단계별 프로세스를 설명합니다. 마지막으로 VS의 병렬 설계에 대해 논의합니다.

### 2.3.1 개요 (Overview)

VS는 서번트 증후군(Savant Syndrome)에서 영감을 받아 설계된 새로운 기법입니다. VS는 기계학습(machine learning) 기법을 활용하여 최적화 문제(optimization problem)를 해결하는 방법을 학습하고자 합니다 (Pinel et al., 2013). 서번트 증후군의 아날로지(analogy)에 따라, VS는 주어진 문제를 해결할 수 있는 패턴을 학습합니다. 이 패턴은 이전에 해결된 문제 인스턴스(instances)로부터 기계학습을 통해 추출됩니다. VS는 학습하는 데 사용하는 기준(reference) 알고리즘의 동작 원리를 알 필요가 없습니다. 이는 실제 서번트가 자신들의 능력과 관련된 원리를 이해하지 못하는 것과 유사합니다.

VS의 학습 과정에서는 문제 인스턴스를 분할(partitioning)하며, 서번트처럼 작은 조각들을 결합하여 전체 해(global solution)를 도출할 수 있습니다.

서번트가 반복(repetition)과 학습(learning)을 통해 능력을 향상시킬 수 있듯이, VS도 훈련에 사용하는 문제 인스턴스를 개선함으로써 더 정확한 결과를 계산할 수 있습니다. 훈련이 완료되면, VS는 한 번도 본 적 없는 새로운 문제 인스턴스를 추가적인 학습 없이도 해결할 수 있습니다. 실제 서번트와 마찬가지로 VS는 확률적(stochastic)이기 때문에 정확한 해를 보장하지 않으며, 여러 번 실행하면 서로 다른 근사 해를 생성할 수 있습니다.

또한 실제 서번트가 병렬 처리(parallel processing) 능력을 갖추고 있는 것으로 여겨지는 것처럼, VS 역시 다수의 연산 자원을 효과적으로 활용할 수 있도록 병렬 처리를 지원합니다. VS의 설계는 모든 단계가 대규모 병렬 방식으로 실행될 수 있도록 되어 있으며, 이로 인해 실행 시간을 크게 줄이고, 탐색 공간(search space)을 보다 잘 탐색하여 더 나은 해를 찾을 수 있으며, 문제의 크기 증가에도 효과적으로 확장(scale)될 수 있습니다.

---

### 2.3.2 VS의 학습 (Training of VS)

VS는 사전에 해결된 문제 인스턴스로부터 학습됩니다. 학습은 오직 입력(문제 인스턴스)과 출력(해결 결과) 간의 관계만을 사용하며, 이 해를 계산한 기준(reference) 알고리즘이 어떤 방식으로 작동하는지는 알 필요가 없습니다. 사실, VS는 많은 최적화 문제에 대해 존재하는 벤치마크 데이터셋으로부터도 학습할 수 있습니다.

VS를 적용하기 위한 첫 단계는 해결된 문제 인스턴스 집합으로부터 VS가 학습할 수 있는 훈련 데이터셋(training set)을 구축하는 것입니다.

VS의 핵심 설계 원칙 중 하나는 문제의 구성 요소 간의 관계를 학습하는 것입니다. 가장 단순한 경우는 변수 하나만 고려하는 단변수(univariate) 분석이며, 더 복잡한 경우는 다변수(multivariate) 모델도 가능합니다. 여기서는 VS 워크플로우를 설명하기 위해 단변수 경우를 기준으로 설명합니다.

단변수의 경우, 문제의 변수 개수만큼 훈련 샘플이 만들어집니다. 즉, 하나의 문제 인스턴스는 해당 문제의 변수 수만큼의 훈련 예제를 생성합니다.
아래 그림 2.1은 해결된 문제 인스턴스들을 어떻게 훈련 세트로 변환하는지를 보여줍니다.

* 각 훈련 벡터는 k개의 특징(feature)으로 이루어진 벡터 (x<sub>j1</sub>, ..., x<sub>jk</sub>)와 정답 레이블 y<sub>j</sub>로 구성됩니다.
* 레이블 y<sub>j</sub>는 문제의 변수 j가 해에서 어떤 값을 갖는지를 나타냅니다.
* 주요 과제는 정확도를 높이는 특징(feature)을 선택하는 것이며, 이는 문제에 따라 달라집니다.

이러한 훈련 세트가 준비되면, 지도학습(Supervised Learning) 모델이 학습됩니다. 지도학습은 입력-출력 쌍을 기반으로 입력과 출력 간의 매핑 함수를 근사하는 작업을 의미하며 (Russell and Norvig, 2010), 출력 값이 유한한 경우에는 분류(classification) 문제라고 합니다.

---

### 2.3.3 VS의 실행 (Execution of VS)

훈련이 완료되면, VS는 보지 못한 새로운 문제 인스턴스를 예측(Prediction)과 개선(Improvement)의 두 단계로 해결할 수 있습니다.

#### 2.3.3.1 예측 단계 (Prediction Phase)

예측 단계에서는 훈련된 분류기(classifier)를 사용하여 새로운 문제 인스턴스에 대한 해를 예측합니다. 단변수 모델의 경우, 문제의 각 변수는 독립적으로 예측될 수 있습니다.
즉, 훈련 시와 동일한 방식으로 각 변수에 대한 특징을 추출하고, 이를 통해 변수마다 분류기의 출력을 얻어냅니다.
모든 변수에 대한 예측 결과를 조합하여 전체 해(solution)를 생성합니다.

대부분의 기계학습 라이브러리는 다중 클래스 분류(multi-class classification)에 대해 확률 분포(probability distribution)를 반환하는 기능을 지원합니다 (Wu et al., 2004). 이 경우, 분류기의 출력은 단일 라벨이 아니라 가능한 클래스마다 확률이 포함된 벡터입니다.
이때는 각 변수마다 argmax를 취해 가장 높은 확률의 클래스를 선택하여 해를 구성할 수 있습니다.

#### 2.3.3.2 개선 단계 (Improvement Phase)

예측된 해는 탐색 절차(search procedure)와 휴리스틱(heuristic)을 사용하여 개선될 수 있습니다. 예를 들어, 지역 탐색(Local Search, LS) 알고리즘을 적용하거나, 진화 알고리즘(EA) 등의 메타휴리스틱(metaheuristic) 기법을 사용해 초기 해를 개선할 수 있습니다.

제약 조건이 있는 문제에서는 예측 단계의 오차 또는 개선 과정에서의 수정으로 인해 제약을 위반할 수 있습니다. 따라서, 모든 제약을 만족하도록 조정하는 보정 함수(correction function)가 필요합니다.

예측 결과가 확률 분포인 경우, 이 확률 분포를 기반으로 여러 후보 해(candidate solutions)를 생성하고, 이를 각각 개선할 수 있습니다. 또는 이 후보 해 집합을 EA와 같은 집단 기반 최적화(population-based optimization)의 초기 세대로 사용할 수도 있습니다.

---

### 2.3.4 VS의 병렬성 (Parallelism in VS)

VS는 그 설계 구조상 대규모 병렬 실행에 적합합니다. 이는 MapReduce 방식(Dean and Ghemawat, 2004)의 사례로 해석될 수 있으며, 예측과 개선 단계 모두 병렬화가 가능합니다.

* **예측 단계**에서는 학습된 분류기의 복사본 여러 개를 사용해 병렬로 예측을 수행할 수 있습니다. 각 변수에 대해 독립적으로 예측되기 때문에 통신 오버헤드 없이 병렬화가 가능합니다.
* 특히, 문제 변수 수만큼의 노드가 있다면 문제의 크기를 늘려도 응답 시간을 거의 일정하게 유지할 수 있습니다.
* **개선 단계**에서는 예측된 확률 분포를 바탕으로 여러 해를 만들고 각 해를 병렬로 개선할 수 있습니다. 이 또한 독립적이므로 통신 없이 병렬 처리 가능하며, 최종적으로 가장 좋은 해를 선택하여 반환합니다.

전체 병렬 VS 워크플로우는 다음과 같습니다:

1. 문제 변수 개수만큼 분류기를 생성하여 각 변수의 예측 확률 벡터 P(ŷ<sub>i</sub>)를 출력
2. 동기화 후 r개의 후보 해를 확률 분포에 따라 생성
3. 각각의 후보 해를 병렬로 개선
4. 다시 동기화 후, 가장 우수한 해를 선택하여 반환

---

## 3.3 서번트에서 영감을 받은 계산 기법

(Savant-Inspired Computational Methods)

가상 서번트(Virtual Savant, VS) 패러다임은 이름 그대로 서번트 증후군(Savant Syndrome)에서 영감을 받아 설계되었습니다. 앞서 제2장에서 다룬 것처럼, 실제 서번트는 특정 영역에서 놀라운 능력을 발휘하지만 다른 인지 능력은 손상된 상태로 존재합니다. 이 절에서는 서번트 현상을 수학적 또는 계산적 모델로 형식화하려는 기존 연구들을 정리합니다.

---

### 서번트 행동의 수학적 모델링

**Snyder (2009)**는 창의성(creativity), 직관(intuition), 분석적 사고(analytical reasoning) 간의 균형이 인간의 인지적 능력을 결정한다고 주장했습니다. 그는 “의식적 사고(conscious thought)”가 **높은 수준의 통합(integration)** 을 가능하게 하지만, 동시에 **저수준 정보의 세부 인지(detailed low-level perception)** 를 억제한다고 주장합니다. 이에 따라 일반인은 무의식적으로 저수준 감각정보를 필터링하지만, 서번트는 이 억제 과정이 결핍되어 오히려 세부 정보에 민감한 능력을 갖는다는 가설이 제시되었습니다.

이 개념은 **부분 기능 결손(partial dysfunction)** 또는 **억제 해제(disinhibition)** 모델로 불리며, 몇몇 계산 모델에 영감을 주었습니다.

---

### 예술 및 패턴 생성에서의 서번트 모방

**Cohen et al. (2005)**는 “Aaron”이라는 인공지능 그림 그리기 프로그램을 통해 창의성의 수학적 모델링을 시도했습니다. 이 시스템은 몇 가지 간단한 규칙을 기반으로 인물화 및 추상화를 생성했으며, 제한된 규칙 기반 시스템에서도 창의적인 결과물이 가능함을 보여주었습니다. 이는 서번트가 보이는 정형화된(하지만 정확한) 행동과 유사합니다.

**Partridge and Rowe (1994)**는 음악 작곡을 수행하는 프로그램을 개발했으며, 이는 몇 가지 스타일 규칙과 기억 기반 생성(memory-based generation)을 조합하여, 서번트의 음악 작곡 패턴과 유사한 산출물을 생성했습니다.

---

### 인지적 결손 기반 인공 지능 설계

**French (1999)**는 인간의 인지 과정에서 “결손(deficits)” 또는 “비표준 처리(non-standard processing)”이 창의성의 근원일 수 있음을 주장하며, 전통적인 지능(예: 언어, 추론)에 중점을 둔 인공지능 시스템은 인간의 창의성과 본질적으로 다를 수밖에 없다고 보았습니다. 그는 **제한된 처리 능력(limited processing capacity)** 과 **비표준 표현(representation)** 을 인공 지능 설계에 도입할 필요가 있다고 말합니다.

이러한 관점은 VS의 설계 방향과 일치합니다. VS는 전지적 지능(all-knowing intelligence)을 지향하지 않고, 제한된 입력, 특정 과업, 국소적 판단(local decision)에 기반하여 전체 해(solution)를 조합합니다. 즉, 정확하고 완전한 최적화보다는 **우수한 부분적 전략(partial but effective strategy)** 을 추구합니다.

---

### 확률적 서번트 시뮬레이션

**Mottron et al. (2006)**은 서번트의 인지 행동이 규칙 기반이라기보다는 **패턴 통계(pattern statistics)** 에 기반한다고 주장했습니다. 이 모델에 따르면, 서번트는 반복되는 구조나 확률적으로 높은 패턴을 학습하고, 이를 통해 규칙처럼 보이는 행동을 생성합니다.

이러한 점에서 VS는 학습된 분류기(classifier)를 통해 높은 확률의 조각 해(fragmented solution)를 식별하고, 이를 조합하여 최종 해(solution)를 구성합니다. 다시 말해, VS는 “지능적 추론”보다는 “고성능의 통계적 반응(statistical response)”을 핵심 원리로 삼습니다. 이는 서번트의 특성과 본질적으로 유사합니다.

---

## 3.4 요약 및 논의 (Summary and Discussion)

본 장에서는 가상 서번트(Virtual Savant, VS) 패러다임과 관련된 주요 연구 분야들을 개관하였습니다. 네 가지 축을 중심으로 요약하면 다음과 같습니다:

---

### (1) 병렬 프로그램의 자동 생성 (Automatic Generation of Parallel Programs)

* 병렬 코드를 자동 생성하려는 시도는 다양한 수준에서 존재합니다:
  예를 들어, 컴파일러 최적화, 프로그램 합성, 모델 기반 설계 등.
* 이러한 접근은 대부분 명시적인 구조 분석(explicit structure analysis)을 전제로 하며,
  사전 정의된 템플릿이나 규칙(rule set)을 기반으로 합니다.
* 반면, VS는 **경험적 학습(experiential learning)** 을 통해 병렬 구조를 내재적으로 파악하고,
  이를 바탕으로 프로그램(또는 해법)을 생성한다는 점에서 차별화됩니다.

---

### (2) 최적화를 위한 기계학습 (Learning for Optimization)

* 최근 기계학습을 통해 최적화 문제의 해를 직접 생성하거나,
  전통적 알고리즘의 요소를 학습하려는 연구가 활발히 진행되고 있습니다.
* 대표적으로: Pointer Networks, 강화학습 기반 휴리스틱, Graph Neural Networks 기반 솔버,
  예측-최적화(Predict-then-Optimize) 프레임워크 등이 있습니다.
* VS 역시 이러한 흐름 속에 위치하나,
  **단일 구조 예측 → 전역 해 구성 → 개선 단계**라는 **3단계 처리 구조**를 갖는다는 점에서
  고유한 설계 철학을 반영합니다.

---

### (3) 서번트에서 영감을 받은 계산 기법 (Savant-Inspired Computational Models)

* 서번트의 인지 구조는 비정상적(disordered)이지만, 특정 과업에서는 비정상적으로 뛰어난 능력을 보입니다.
* 이에 따라 일부 연구에서는 **인지 결손(cognitive deficit)**, **억제 해제(disinhibition)**,
  **정보 필터링 결함(filtering failure)** 등을 창의성 또는 특화 지능의 원천으로 간주합니다.
* VS는 이러한 서번트 모델을 수학적 구조로 수용하여,
  **전역 최적화는 못하더라도, 고성능 부분적 조각(partial fragment)을 생성하는 인공 서번트**로 설계됩니다.

---

### (4) 통합 논의

VS는 다음과 같은 독특한 연구 방향을 제안합니다:

* **해법 구조를 학습하는 인공 에이전트(agent that learns problem structure)**
* **서번트와 유사한 능력 발현을 모방하는 지능 체계**
* **병렬 구조 및 최적화 해법 생성을 동시에 다루는 통합 패러다임**

이는 기존의 고전적 최적화(classical optimization), 전통적 병렬 프로그래밍(parallel programming),
지배적인 신경망 기반 인공지능과는 다른 철학을 내포합니다.

다음은 요청하신 **4.2절 "NRP를 위한 VS 설계(VS design for the NRP)"**의 한국어 번역입니다. 모든 전문 용어는 괄호로 병기하였습니다.

---

### 4.2 NRP를 위한 가상 서번트(VS) 설계

(**VS design for the NRP**)

제2.3절에서 제시된 **VS의 일반 프레임워크(Virtual Savant framework)**는, 해결하고자 하는 특정 문제에 맞게 **구체화(instantiation)** 되어야 한다. **NRP(Next Release Problem)**의 경우, **정확한 알고리즘(exact algorithm)**으로 해결된 문제 인스턴스들의 데이터셋을 이용하여 VS를 학습시킨다.

**그림 4.1(Figure 4.1)**은 NRP를 위한 **학습 데이터셋 구축 과정(training set generation process)**을 개략적으로 보여준다. 데이터셋 내의 각 문제 인스턴스는 반복적으로 처리되며, **각 요구사항(requirement)**은 VS 학습 단계에서 **독립된 관측값(observation)**으로 취급된다.

학습 시에는 다양한 **피처(feature)** 조합을 고려할 수 있다. 실제로, 본 연구에서는 여러 조합을 실험적으로 분석하였으며, 그 결과는 **제4.4.2.1절**에서 보고된다. **그림 4.1**에 나타난 학습 데이터 생성 과정은 **이 실험들에서 가장 좋은 성능을 보인 피처 조합**을 기준으로 설명된다.

하나의 요구사항에 해당하는 **학습 벡터(training vector)**는 다음의 피처들로 구성된다:

* 해당 요구사항의 **비용(cost)**
* 해당 요구사항이 발생시키는 **수익(revenue)**
* 해당 문제 인스턴스에 공통적으로 적용되는 **총 예산(total budget)**

분류 라벨(classification label)은 **이진 값(binary value)**으로, 해당 요구사항이 **다음 소프트웨어 릴리스(next software release)**에 포함되는지 여부를 나타낸다:

* 포함되는 경우: 1
* 포함되지 않는 경우: 0
  (참조 알고리즘(reference algorithm)에 따라 결정됨)

각 문제 인스턴스는, 그 안에 포함된 요구사항의 수만큼 **관측값(observations)**을 학습 데이터셋에 기여한다.
이러한 방식은 **학습 과정에서 필요한 참조 해(reference solutions)의 수를 획기적으로 줄일 수 있는 장점**이 있다.

---

기계학습 분류기(machine learning classifier)의 학습이 완료되면, VS(Virtual Savant)는 학습에 사용된 것보다 **더 크고**, **이전에 보지 못한** 새로운 문제 인스턴스들도 처리할 수 있게 된다.
**그림 4.2(Figure 4.2)**는 **NRP(Next Release Problem)**를 해결할 때 VS가 수행하는 **작업 흐름(workflow)**을 개략적으로 보여준다.

제2.3절에서 설명한 바와 같이, VS의 실행은 두 개의 단계로 구성된다:

1. 예측 단계 (Prediction Phase)
2. 개선 단계 (Improvement Phase)

---

### 📌 예측 단계 (Prediction Phase)

* VS는 입력으로 새로운 **NRP 문제 인스턴스**를 받는다.
* 기계학습 분류기는 **각 요구사항(requirement)**을 개별적으로 고려하여 학습되었기 때문에,
  동일한 분류기의 여러 복사본(copies)을 **동시에 병렬 실행(parallel execution)**할 수 있다.
* 즉, 새로운 문제 인스턴스를 분할하여, 각 요구사항에 대해 **서로 다른 분류기 인스턴스**가 예측을 수행할 수 있다.
* 각 분류기의 출력은, 해당 요구사항이 **다음 릴리스에 포함될 확률(probability of inclusion)**이다.
* 모든 분류기들의 출력 결과는 취합되어, **각 요구사항의 포함 확률을 담은 하나의 확률 벡터(probability vector)**로 결합된다.

---

### 📌 개선 단계 (Improvement Phase)

* 예측 단계에서 생성된 **확률 벡터**는 다양한 **후보 해(candidate solutions)**를 생성하는 데 사용된다.
* 후보 해를 생성하는 전략은 다양할 수 있으며,
  NRP의 경우에는 다음 방식이 사용되었다:

  * 요구사항 포함 확률을 기반으로 **무작위 샘플링(random sampling)**을 수행하는 일반적인 방법.
* 생성된 각 해는 이후 **개선 연산자(improvement operator)**에 의해 수정되며, 이는 해의 품질을 향상시키는 것을 목표로 한다.

이 개선 단계는 특히 예측 단계의 성능이 저조한 문제 인스턴스에 대해 매우 중요한 역할을 한다.
또한, 이 단계 역시 **대규모 병렬화(massive parallelism)**가 가능하다.
→ 즉, 각 컴퓨팅 자원마다 서로 다른 해를 생성하고, 각각 독립적으로 개선할 수 있다.

**주의할 점**: 생성된 해는 **비현실적(infeasible)**일 수 있다.
즉, 예산 제약(budget constraint)을 만족하지 않을 수 있으므로,
개선 단계에서는 해의 **타당성(feasibility)**을 보장하기 위한 **보정 연산자(correction operator)**가 필요하다.

다양한 개선 연산자 및 보정 연산자의 대안들은 이후 절에서 설명된다.

---

### 📌 알고리즘 1: VS 기반 NRP 해결 절차

* **3\~5행** 루프:

  * 예측 단계에 해당
  * 각 요구사항에 대해, **비용(cost)**, **수익(revenue)**, **총 예산(total budget)**을 입력으로 하여 포함 확률을 예측

* **6\~9행** 루프:

  * 개선 단계에 해당
  * 예측된 확률을 바탕으로 후보 해를 생성하고, 개선 연산자를 적용하여 품질을 향상

* **10행**:

  * 생성된 후보 해들 중 **최적의 해(best solution)**를 반환

위에서 설명한 바와 같이, 두 루프 모두 **병렬화가 매우 용이(parallelizable)**하다.
그러나 NRP에 대한 실험에서는 VS의 대규모 병렬 구조를 실현하지 않고,
**단일 스레드(sequential implementation)**로 구현하였다.
그 이유는 VS가 **NP-완전(NP-hard)** 문제를 얼마나 효과적으로 풀 수 있는지를 평가하는 것이 실험의 주 목적이기 때문이다.

VS의 병렬화 가능성(parallel potential)은 **제5장에서 HCSP 문제를 해결할 때** 집중적으로 다뤄진다.

---
